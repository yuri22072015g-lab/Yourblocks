<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D Parkour Game ‚Äî –ï–¥–∏–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –¥–ª—è –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.75);
            color: #fff;
            padding: 14px 20px;
            border-radius: 12px;
            font-size: 15px;
            backdrop-filter: blur(4px);
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 100;
        }
        #ui span { color: #ffaa00; font-weight: bold; }
        #players-count {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            color: #0ff;
            padding: 8px 18px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 16px;
            border: 1px solid #0ff;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
            z-index: 100;
            backdrop-filter: blur(4px);
        }
        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            color: #ffaa00;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            border: 1px solid #ffaa00;
            z-index: 100;
        }
        #server-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: #aaa;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
        }
        #test-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #4CAF50;
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 18px;
            border: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(76,175,80,0.5);
            display: none;
        }
        #test-button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="ui">
        ‚ö° <span>WASD</span> ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ ¬∑ <span>–ü—Ä–æ–±–µ–ª</span> ‚Äî –ø—Ä—ã–∂–æ–∫ (–∫–¥ 2 —Å–µ–∫)<br>
        üñ±Ô∏è <span>–ü–ö–ú (–±—ã—Å—Ç—Ä–æ)</span> ‚Äî –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã ¬∑ <span>–ö–æ–ª—ë—Å–∏–∫–æ</span> ‚Äî –∑—É–º<br>
        ‚ùå <span style="color:#ff5555">–ö—Ä–∞—Å–Ω—ã–µ –±–ª–æ–∫–∏ = —Å–º–µ—Ä—Ç—å</span> (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)<br>
        üë• <span style="color:#88ccff">–í—Å–µ –∏–≥—Ä–æ–∫–∏</span> –ø–æ–¥–∫–ª—é—á–∞—é—Ç—Å—è –∫ –µ–¥–∏–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É
    </div>
    <div id="players-count">
        üë• –ò–≥—Ä–æ–∫–æ–≤ –æ–Ω–ª–∞–π–Ω: <span id="player-counter">1</span>
    </div>
    <div id="connection-status">
        üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –µ–¥–∏–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É...
    </div>
    <div id="server-info">
        üñ•Ô∏è –ï–¥–∏–Ω—ã–π —Å–µ—Ä–≤–µ—Ä: multiplayer-server.herokuapp.com
    </div>
    <button id="test-button" onclick="window.open(window.location.href, '_blank')">
        üéÆ –û—Ç–∫—Ä—ã—Ç—å –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞ (—Ç–æ—Ç –∂–µ —Å–µ—Ä–≤–µ—Ä)
    </button>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <!-- Socket.IO –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –µ–¥–∏–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

    <script>
        (function() {
            // ==================== –≠–õ–ï–ú–ï–ù–¢–´ UI ====================
            const statusEl = document.getElementById('connection-status');
            const playerCounterSpan = document.getElementById('player-counter');
            const testButton = document.getElementById('test-button');
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è —Ç–µ—Å—Ç–∞
            setTimeout(() => {
                testButton.style.display = 'block';
            }, 2000);

            // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–¶–ï–ù–´ ====================
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ==================== –ö–ê–ú–ï–†–ê ====================
            const yawObject = new THREE.Object3D();
            const pitchObject = new THREE.Object3D();
            yawObject.add(pitchObject);
            pitchObject.add(camera);
            scene.add(yawObject);

            let cameraDistance = 7;
            const minDistance = 3;
            const maxDistance = 15;
            camera.position.set(0, 2.5, cameraDistance);

            document.addEventListener("wheel", (e) => {
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
            });

            // ==================== –û–°–í–ï–©–ï–ù–ò–ï ====================
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(20, 30, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // ==================== –§–ò–ó–ò–ö–ê ====================
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);

            const groundMaterial = new CANNON.Material("groundMaterial");
            const playerMaterial = new CANNON.Material("playerMaterial");
            
            const contactMaterial = new CANNON.ContactMaterial(playerMaterial, groundMaterial, {
                friction: 0.0,
                restitution: 0.0,
            });
            world.addContactMaterial(contactMaterial);
            world.defaultContactMaterial = contactMaterial;

            // ==================== –ì–†–£–ü–ü–´ –î–õ–Ø –°–ú–ï–†–¢–ò ====================
            const deathBlocks = [];

            // ==================== –°–û–ó–î–ê–ù–ò–ï –£–†–û–í–ù–Ø ====================
            
            // –ó–µ–º–ª—è
            const groundMesh = new THREE.Mesh(
                new THREE.BoxGeometry(30, 2, 30),
                new THREE.MeshStandardMaterial({ color: 0x3a4a5a })
            );
            groundMesh.position.set(0, -1, 10);
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            groundBody.addShape(new CANNON.Box(new CANNON.Vec3(15, 1, 15)));
            groundBody.position.copy(groundMesh.position);
            world.addBody(groundBody);

            // –£—Ä–æ–≤–µ–Ω—å 1 (—Ü–≤–µ—Ç–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã)
            for (let i = 0; i < 15; i++) {
                const platformMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 8),
                    new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 15, 0.8, 0.5) })
                );
                platformMesh.position.set(0, 2, -i * 10);
                platformMesh.castShadow = true;
                platformMesh.receiveShadow = true;
                scene.add(platformMesh);

                const platformBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                platformBody.addShape(new CANNON.Box(new CANNON.Vec3(4, 0.5, 4)));
                platformBody.position.copy(platformMesh.position);
                world.addBody(platformBody);
            }

            // –£—Ä–æ–≤–µ–Ω—å 2 —Å –∫—Ä–∞—Å–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏
            const startZ = -160;
            for (let i = 0; i < 20; i++) {
                const platformMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                platformMesh.position.set(0, 2, startZ - i * 10);
                platformMesh.castShadow = true;
                platformMesh.receiveShadow = true;
                scene.add(platformMesh);

                const platformBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                platformBody.addShape(new CANNON.Box(new CANNON.Vec3(4, 0.5, 4)));
                platformBody.position.copy(platformMesh.position);
                world.addBody(platformBody);

                for (let x = -3; x <= 3; x += 3) {
                    if (x === 0) continue;
                    if (Math.random() > 0.35) {
                        const deathMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 1, 2),
                            new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x330000 })
                        );
                        deathMesh.position.set(x, 3, startZ - i * 10);
                        deathMesh.castShadow = true;
                        deathMesh.receiveShadow = true;
                        scene.add(deathMesh);

                        const deathBody = new CANNON.Body({ 
                            mass: 0,
                            material: groundMaterial,
                            collisionResponse: false
                        });
                        deathBody.addShape(new CANNON.Box(new CANNON.Vec3(1, 0.5, 1)));
                        deathBody.position.copy(deathMesh.position);
                        world.addBody(deathBody);
                        
                        deathBlocks.push(deathBody);
                    }
                }
            }

            // ==================== –ò–ì–†–û–ö (–õ–û–ö–ê–õ–¨–ù–´–ô) ====================
            const localPlayerBody = new CANNON.Body({
                mass: 5,
                material: playerMaterial,
                linearDamping: 0.0,
                angularDamping: 0.0,
                fixedRotation: true,
                collisionResponse: true
            });
            localPlayerBody.addShape(new CANNON.Sphere(0.9));
            localPlayerBody.position.set(0, 8, 5);
            world.addBody(localPlayerBody);

            const spawnPosition = new CANNON.Vec3(0, 8, 5);

            // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏ –∏–≥—Ä–æ–∫–∞ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º —Ü–≤–µ—Ç–æ–º
            function createPlayerModel(playerId, isLocal = false) {
                const group = new THREE.Group();
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ ID –∏–≥—Ä–æ–∫–∞
                let hue;
                if (isLocal) {
                    hue = 0.6; // –°–∏–Ω–∏–π –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
                } else {
                    // –î–ª—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ - —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Ö ID
                    const hash = playerId.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
                    hue = (hash % 100) / 100;
                }
                
                const mainColor = new THREE.Color().setHSL(hue, 0.9, 0.5);
                const limbColor = new THREE.Color().setHSL(hue, 0.8, 0.3);
                
                const tBodyMat = new THREE.MeshStandardMaterial({ color: mainColor });
                const tLimbMat = new THREE.MeshStandardMaterial({ color: limbColor });
                const tHeadMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });

                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 0.8), tBodyMat);
                torso.position.y = 1.6;
                torso.castShadow = true;
                group.add(torso);

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), tHeadMat);
                head.position.y = 3;
                head.castShadow = true;
                group.add(head);

                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), tLimbMat);
                leftLeg.position.set(-0.4, 0.2, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), tLimbMat);
                rightLeg.position.set(0.4, 0.2, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), tLimbMat);
                leftArm.position.set(-0.8, 1.8, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), tLimbMat);
                rightArm.position.set(0.8, 1.8, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                return group;
            }

            // –°–æ–∑–¥–∞—ë–º –º–æ–¥–µ–ª—å –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            const localModel = createPlayerModel('local', true);
            scene.add(localModel);

            // ==================== –ï–î–ò–ù–´–ô –°–ï–†–í–ï–† –î–õ–Ø –í–°–ï–• –ò–ì–†–û–ö–û–í ====================
            const otherPlayers = new Map(); // socketId -> { model, targetPosition }
            
            // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ï–î–ò–ù–û–ú–£ —Å–µ—Ä–≤–µ—Ä—É (–æ–¥–∏–Ω —Å–µ—Ä–≤–µ—Ä –¥–ª—è –≤—Å–µ—Ö)
            // –≠—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ —Å–æ–∑–¥–∞–Ω –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–Ω—ã—Ö –∏–≥—Ä
            const SOCKET_SERVER_URL = 'https://multiplayer-server-demo.onrender.com';
            
            console.log('üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –µ–¥–∏–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É:', SOCKET_SERVER_URL);
            
            const socket = io(SOCKET_SERVER_URL, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 10,
                timeout: 20000,
                forceNew: true
            });

            // –°—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            socket.on('connect', () => {
                console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ –µ–¥–∏–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É! ID:', socket.id);
                statusEl.textContent = 'üü¢ –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ: ' + otherPlayers.size + ' –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤';
                statusEl.style.color = '#00ff00';
                statusEl.style.borderColor = '#00ff00';
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ—é –ø–æ–∑–∏—Ü–∏—é –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
                socket.emit('player-join', {
                    id: socket.id,
                    position: {
                        x: localPlayerBody.position.x,
                        y: localPlayerBody.position.y,
                        z: localPlayerBody.position.z
                    }
                });
            });

            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–µ–∫—É—â–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
            socket.on('current-players', (players) => {
                console.log('üìã –¢–µ–∫—É—â–∏–µ –∏–≥—Ä–æ–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ:', players.length);
                
                // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
                otherPlayers.forEach((player) => {
                    scene.remove(player.model);
                });
                otherPlayers.clear();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤, –∫—Ä–æ–º–µ —Å–µ–±—è
                players.forEach(player => {
                    if (player.id !== socket.id) {
                        addOtherPlayer(player.id, player.position);
                    }
                });
                
                updatePlayersCount();
                statusEl.textContent = 'üü¢ –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ: ' + otherPlayers.size + ' –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤';
            });

            // –ù–æ–≤—ã–π –∏–≥—Ä–æ–∫ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è
            socket.on('player-joined', (data) => {
                console.log('‚ûï –ù–æ–≤—ã–π –∏–≥—Ä–æ–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ:', data.id);
                if (data.id !== socket.id && !otherPlayers.has(data.id)) {
                    addOtherPlayer(data.id, data.position);
                    updatePlayersCount();
                    statusEl.textContent = 'üü¢ –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ: ' + otherPlayers.size + ' –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤';
                }
            });

            // –ò–≥—Ä–æ–∫ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è
            socket.on('player-moved', (data) => {
                const player = otherPlayers.get(data.id);
                if (player) {
                    if (!player.targetPosition) {
                        player.targetPosition = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                    } else {
                        player.targetPosition.set(data.position.x, data.position.y, data.position.z);
                    }
                }
            });

            // –ò–≥—Ä–æ–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è
            socket.on('player-disconnected', (id) => {
                console.log('‚ûñ –ò–≥—Ä–æ–∫ –ø–æ–∫–∏–Ω—É–ª —Å–µ—Ä–≤–µ—Ä:', id);
                const player = otherPlayers.get(id);
                if (player) {
                    scene.remove(player.model);
                    otherPlayers.delete(id);
                    updatePlayersCount();
                    statusEl.textContent = 'üü¢ –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ: ' + otherPlayers.size + ' –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤';
                }
            });

            // –ü–æ—Ç–µ—Ä—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            socket.on('disconnect', () => {
                console.log('‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞');
                statusEl.textContent = 'üî¥ –û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞';
                statusEl.style.color = '#ff5555';
                statusEl.style.borderColor = '#ff5555';
                
                otherPlayers.forEach((player) => {
                    scene.remove(player.model);
                });
                otherPlayers.clear();
                updatePlayersCount();
            });

            // –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            socket.on('connect_error', (error) => {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É:', error);
                statusEl.textContent = '‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É';
                statusEl.style.color = '#ffaa00';
                statusEl.style.borderColor = '#ffaa00';
            });

            // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥—Ä—É–≥–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            function addOtherPlayer(id, position) {
                try {
                    const model = createPlayerModel(id, false);
                    model.position.set(position.x, position.y, position.z);
                    scene.add(model);
                    
                    otherPlayers.set(id, {
                        model,
                        targetPosition: new THREE.Vector3(position.x, position.y, position.z)
                    });
                    console.log(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –∏–≥—Ä–æ–∫ ${id} –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏`, position);
                } catch (e) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏–≥—Ä–æ–∫–∞:', e);
                }
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç—á–∏–∫–∞ –∏–≥—Ä–æ–∫–æ–≤
            function updatePlayersCount() {
                playerCounterSpan.textContent = 1 + otherPlayers.size;
            }

            // ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï ====================
            const keys = {};
            document.addEventListener("keydown", (e) => keys[e.code] = true);
            document.addEventListener("keyup", (e) => keys[e.code] = false);
            document.addEventListener("contextmenu", (e) => e.preventDefault());

            let mouseDown = false;
            const cameraSensitivity = 0.006;

            document.addEventListener("mousedown", (e) => {
                if (e.button === 2) mouseDown = true;
            });
            document.addEventListener("mouseup", (e) => {
                if (e.button === 2) mouseDown = false;
            });
            document.addEventListener("mousemove", (e) => {
                if (!mouseDown) return;
                yawObject.rotation.y -= e.movementX * cameraSensitivity;
                pitchObject.rotation.x -= e.movementY * cameraSensitivity;
                pitchObject.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, pitchObject.rotation.x));
            });

            // ==================== –ü–†–´–ñ–û–ö ====================
            let jumpCooldown = 2.0;
            let lastJumpTime = -Infinity;

            function respawn() {
                localPlayerBody.position.copy(spawnPosition);
                localPlayerBody.velocity.set(0, 0, 0);
                localPlayerBody.angularVelocity.set(0, 0, 0);
            }

            // ==================== –û–¢–ü–†–ê–í–ö–ê –ü–û–ó–ò–¶–ò–ò –ù–ê –°–ï–†–í–ï–† ====================
            let lastSendTime = 0;
            function sendPosition() {
                const now = Date.now();
                if (now - lastSendTime > 50) { // 20 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
                    if (socket && socket.connected) {
                        socket.emit('player-move', {
                            id: socket.id,
                            position: {
                                x: localPlayerBody.position.x,
                                y: localPlayerBody.position.y,
                                z: localPlayerBody.position.z
                            }
                        });
                    }
                    lastSendTime = now;
                }
            }

            // ==================== –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ====================
            const clock = new THREE.Clock();
            let walkTime = 0;
            const deathHeight = -20;

            function animate() {
                requestAnimationFrame(animate);

                const delta = Math.min(clock.getDelta(), 0.1);
                const elapsedTime = performance.now() / 1000;

                world.step(1 / 60, delta, 3);

                // ========== –ü–†–û–í–ï–†–ö–ê –ù–ê –°–ú–ï–†–¢–¨ ==========
                let dead = false;

                if (localPlayerBody.position.y < deathHeight) {
                    dead = true;
                }

                if (!dead) {
                    const playerPos = localPlayerBody.position;
                    const playerRadius = 0.9;

                    for (let block of deathBlocks) {
                        const blockPos = block.position;
                        const halfExtents = new CANNON.Vec3(1, 0.5, 1);
                        
                        const dx = playerPos.x - blockPos.x;
                        const dy = playerPos.y - blockPos.y;
                        const dz = playerPos.z - blockPos.z;

                        const closestX = Math.max(-halfExtents.x, Math.min(halfExtents.x, dx));
                        const closestY = Math.max(-halfExtents.y, Math.min(halfExtents.y, dy));
                        const closestZ = Math.max(-halfExtents.z, Math.min(halfExtents.z, dz));

                        const distX = dx - closestX;
                        const distY = dy - closestY;
                        const distZ = dz - closestZ;

                        const distSq = distX*distX + distY*distY + distZ*distZ;
                        
                        if (distSq < playerRadius * playerRadius) {
                            dead = true;
                            break;
                        }
                    }
                }

                if (dead) {
                    respawn();
                }

                // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –õ–û–ö–ê–õ–¨–ù–´–ú –ò–ì–†–û–ö–û–ú ==========
                if (!dead) {
                    const moveSpeed = 12;

                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);

                    let moveX = 0, moveZ = 0;
                    
                    if (keys["KeyW"]) {
                        moveX += forward.x;
                        moveZ += forward.z;
                    }
                    if (keys["KeyS"]) {
                        moveX -= forward.x;
                        moveZ -= forward.z;
                    }
                    if (keys["KeyA"]) {
                        moveX -= right.x;
                        moveZ -= right.z;
                    }
                    if (keys["KeyD"]) {
                        moveX += right.x;
                        moveZ += right.z;
                    }

                    if (moveX !== 0 || moveZ !== 0) {
                        const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                        moveX /= len;
                        moveZ /= len;
                    }

                    localPlayerBody.velocity.x = moveX * moveSpeed;
                    localPlayerBody.velocity.z = moveZ * moveSpeed;

                    if (keys["Space"]) {
                        if (Math.abs(localPlayerBody.velocity.y) < 0.1) {
                            const currentTime = elapsedTime;
                            if (currentTime - lastJumpTime >= jumpCooldown) {
                                localPlayerBody.velocity.y = 10;
                                lastJumpTime = currentTime;
                            }
                        }
                    }

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                    sendPosition();
                }

                // ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –î–†–£–ì–ò–• –ò–ì–†–û–ö–û–í ==========
                otherPlayers.forEach((player) => {
                    if (player.targetPosition) {
                        // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
                        player.model.position.lerp(player.targetPosition, 0.3);
                    }
                });

                // ========== –ê–ù–ò–ú–ê–¶–ò–Ø –•–û–î–¨–ë–´ ==========
                const moving = Math.abs(localPlayerBody.velocity.x) > 0.1 || Math.abs(localPlayerBody.velocity.z) > 0.1;
                if (moving) {
                    walkTime += delta * 12;
                    const swing = Math.sin(walkTime) * 0.7;
                    
                    localModel.children[2].rotation.x = swing; // leftLeg
                    localModel.children[3].rotation.x = -swing; // rightLeg
                    localModel.children[4].rotation.x = -swing; // leftArm
                    localModel.children[5].rotation.x = swing; // rightArm
                } else {
                    localModel.children[2].rotation.x = 0;
                    localModel.children[3].rotation.x = 0;
                    localModel.children[4].rotation.x = 0;
                    localModel.children[5].rotation.x = 0;
                }

                // ========== –ö–ê–ú–ï–†–ê ==========
                const firstPerson = cameraDistance <= minDistance + 0.2;
                if (firstPerson) {
                    camera.position.set(0, 3, 0);
                    localModel.visible = false;
                } else {
                    camera.position.set(0, 2.5, cameraDistance);
                    localModel.visible = true;
                }

                localModel.position.copy(localPlayerBody.position);
                localModel.rotation.y = yawObject.rotation.y;
                yawObject.position.copy(localPlayerBody.position);

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // ==================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø ====================
            setTimeout(() => {
                if (!socket.connected) {
                    console.log('‚ö†Ô∏è –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ–º–æ-—Ä–µ–∂–∏–º');
                    statusEl.textContent = 'üß™ –î–µ–º–æ-—Ä–µ–∂–∏–º (–æ–∂–∏–¥–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞)';
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ–º–æ-–∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
                    const demoIds = ['demo1', 'demo2', 'demo3'];
                    demoIds.forEach((id, index) => {
                        const zPos = -50 - index * 30;
                        addOtherPlayer(id, { x: 0, y: 8, z: zPos });
                    });
                    updatePlayersCount();
                }
            }, 5000);

        })();
    </script>
</body>
</html>
