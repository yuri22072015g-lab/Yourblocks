<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D Parkour ‚Äî P2P –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä (WebRTC)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Arial, sans-serif;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(10, 10, 20, 0.8);
            color: #fff;
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 14px;
            backdrop-filter: blur(4px);
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 100;
            text-align: center;
        }
        #ui span { color: #ffaa00; font-weight: bold; }
        
        #players-count {
            position: absolute;
            bottom: 100px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: #0ff;
            padding: 6px 14px;
            border-radius: 30px;
            font-family: monospace;
            font-size: 14px;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
            z-index: 100;
            backdrop-filter: blur(4px);
            font-weight: bold;
            pointer-events: none;
        }
        
        #instruction {
            position: absolute;
            bottom: 150px;
            left: 15px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 8px 14px;
            border-radius: 30px;
            font-size: 13px;
            z-index: 100;
            pointer-events: none;
            border: 1px solid #4CAF50;
            max-width: 220px;
        }
        
        #connection-status {
            position: absolute;
            top: 80px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            border: 1px solid #0f0;
            z-index: 100;
        }
        
        #room-info {
            position: absolute;
            top: 120px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
            border: 1px solid #ffaa00;
            max-width: 200px;
            word-break: break-word;
        }
        
        #room-input {
            position: absolute;
            top: 180px;
            left: 15px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 20px;
            border: 1px solid #4CAF50;
        }
        
        #room-input input {
            padding: 8px;
            border-radius: 15px;
            border: none;
            background: rgba(255,255,255,0.9);
            width: 120px;
            font-size: 12px;
        }
        
        #room-input button {
            padding: 8px 15px;
            border-radius: 15px;
            border: none;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* –õ–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ */
        #touch-joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(30, 30, 40, 0.6);
            border-radius: 60px;
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        #joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 25px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            transition: transform 0.01s;
            border: 2px solid #4CAF50;
        }
        
        #jump-button {
            position: absolute;
            bottom: 40px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 80, 80, 0.9);
            border-radius: 40px;
            backdrop-filter: blur(8px);
            border: 3px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #jump-button.active {
            background: rgba(255, 40, 40, 1);
            transform: scale(0.95);
        }
        
        /* –û–±–ª–∞—Å—Ç—å –∂–µ—Å—Ç–æ–≤ –¥–ª—è –∫–∞–º–µ—Ä—ã */
        #gesture-area {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            z-index: 150;
            touch-action: none;
            background: transparent;
            pointer-events: auto;
        }
        
        @media (min-width: 768px) {
            #touch-joystick, #jump-button, #gesture-area {
                display: none;
            }
            #instruction {
                bottom: 20px;
                left: 20px;
            }
            #players-count {
                bottom: 20px;
                right: 20px;
            }
        }
    </style>
    <!-- PeerJS –¥–ª—è P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
    <div id="ui">
        ‚ö° <span>WASD</span> (–ü–ö) ¬∑ <span>–î–∂–æ–π—Å—Ç–∏–∫</span> (—Ç–µ–ª–µ—Ñ–æ–Ω)<br>
        üåê <span>P2P –ú–£–õ–¨–¢–ò–ü–õ–ï–ï–†</span> ‚Äî –ø—Ä—è–º–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ<br>
        ‚ùå <span style="color:#ff5555">–ö—Ä–∞—Å–Ω—ã–µ –±–ª–æ–∫–∏ = —Å–º–µ—Ä—Ç—å</span>
    </div>
    <div id="players-count">
        üë• <span id="player-counter">1</span> –≤ –∫–æ–º–Ω–∞—Ç–µ
    </div>
    <div id="connection-status">
        üî¥ –û–∂–∏–¥–∞–Ω–∏–µ...
    </div>
    <div id="room-info">
        üÜî –í–∞—à ID: <span id="peer-id">–≥–µ–Ω–µ—Ä–∞—Ü–∏—è...</span>
    </div>
    <div id="room-input">
        <input type="text" id="peer-input" placeholder="ID –¥—Ä—É–≥–∞">
        <button id="connect-btn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
    </div>
    <div id="instruction">
        üëÜ 1 –ø–∞–ª–µ—Ü: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã<br>
        ‚úåÔ∏è 2 –ø–∞–ª—å—Ü–∞: –∑—É–º (–ø–∏–Ω—á)<br>
        üéÆ –î–∂–æ–π—Å—Ç–∏–∫: –¥–≤–∏–∂–µ–Ω–∏–µ
    </div>

    <!-- –°–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
    <div id="touch-joystick">
        <div id="joystick-handle"></div>
    </div>
    <div id="jump-button">
        –ü–†–´–ñ–û–ö
    </div>
    <div id="gesture-area"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
        (function() {
            // ==================== P2P –°–û–ï–î–ò–ù–ï–ù–ò–ï ====================
            const peer = new Peer({
                host: 'peerjs-server.herokuapp.com',
                port: 443,
                secure: true,
                debug: 2
            });
            
            const connections = new Map(); // –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            let myId = '';
            let roomLeader = false;
            
            const connectionStatus = document.getElementById('connection-status');
            const peerIdSpan = document.getElementById('peer-id');
            const playerCounter = document.getElementById('player-counter');
            
            // –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–π ID
            peer.on('open', (id) => {
                myId = id;
                peerIdSpan.textContent = id;
                connectionStatus.innerHTML = 'üü¢ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π';
                connectionStatus.style.color = '#0f0';
                connectionStatus.style.borderColor = '#0f0';
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            peer.on('connection', (conn) => {
                connectionStatus.innerHTML = 'üü° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';
                
                conn.on('open', () => {
                    connections.set(conn.peer, conn);
                    connectionStatus.innerHTML = 'üü¢ –ò–≥—Ä–æ–∫ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è';
                    playerCounter.textContent = connections.size + 1;
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ—é –ø–æ–∑–∏—Ü–∏—é –Ω–æ–≤–æ–º—É –∏–≥—Ä–æ–∫—É
                    sendPosition(conn);
                    
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
                    conn.on('data', (data) => {
                        handlePlayerData(conn.peer, data);
                    });
                    
                    conn.on('close', () => {
                        connections.delete(conn.peer);
                        removeOtherPlayer(conn.peer);
                        playerCounter.textContent = connections.size + 1;
                        connectionStatus.innerHTML = 'üü° –ò–≥—Ä–æ–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è';
                    });
                });
            });
            
            // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –¥—Ä—É–≥–æ–º—É –∏–≥—Ä–æ–∫—É
            document.getElementById('connect-btn').addEventListener('click', () => {
                const targetId = document.getElementById('peer-input').value.trim();
                if (!targetId) return;
                
                const conn = peer.connect(targetId);
                
                conn.on('open', () => {
                    connections.set(targetId, conn);
                    connectionStatus.innerHTML = 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ ' + targetId.substring(0, 8);
                    playerCounter.textContent = connections.size + 1;
                    
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
                    conn.on('data', (data) => {
                        handlePlayerData(targetId, data);
                    });
                    
                    conn.on('close', () => {
                        connections.delete(targetId);
                        removeOtherPlayer(targetId);
                        playerCounter.textContent = connections.size + 1;
                    });
                });
            });
            
            // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ–º –∏–≥—Ä–æ–∫–∞–º
            function broadcastPosition() {
                if (connections.size === 0) return;
                
                const data = {
                    type: 'position',
                    x: localPlayerBody.position.x,
                    y: localPlayerBody.position.y,
                    z: localPlayerBody.position.z,
                    walkTime: walkTime,
                    moving: Math.abs(localPlayerBody.velocity.x) > 0.1 || Math.abs(localPlayerBody.velocity.z) > 0.1
                };
                
                connections.forEach((conn) => {
                    if (conn.open) {
                        conn.send(data);
                    }
                });
            }
            
            // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –∏–≥—Ä–æ–∫—É
            function sendPosition(conn) {
                if (!conn.open) return;
                
                conn.send({
                    type: 'position',
                    x: localPlayerBody.position.x,
                    y: localPlayerBody.position.y,
                    z: localPlayerBody.position.z,
                    walkTime: walkTime,
                    moving: Math.abs(localPlayerBody.velocity.x) > 0.1 || Math.abs(localPlayerBody.velocity.z) > 0.1
                });
            }
            
            // ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ì–†–û–ö–ê–ú–ò ====================
            const otherPlayers = new Map(); // id -> { model, targetPos, walkTime, moving }
            
            function handlePlayerData(id, data) {
                if (data.type === 'position') {
                    if (!otherPlayers.has(id)) {
                        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
                        const model = createPlayerModel(Math.random());
                        model.position.set(data.x, data.y, data.z);
                        scene.add(model);
                        
                        otherPlayers.set(id, {
                            model: model,
                            targetPos: new THREE.Vector3(data.x, data.y, data.z),
                            walkTime: data.walkTime || 0,
                            moving: data.moving || false
                        });
                    } else {
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ
                        const player = otherPlayers.get(id);
                        player.targetPos.set(data.x, data.y, data.z);
                        player.walkTime = data.walkTime || 0;
                        player.moving = data.moving || false;
                    }
                }
            }
            
            function removeOtherPlayer(id) {
                if (otherPlayers.has(id)) {
                    const player = otherPlayers.get(id);
                    scene.remove(player.model);
                    otherPlayers.delete(id);
                }
            }
            
            // ==================== –°–¶–ï–ù–ê ====================
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ==================== –ö–ê–ú–ï–†–ê ====================
            const yawObject = new THREE.Object3D();
            const pitchObject = new THREE.Object3D();
            yawObject.add(pitchObject);
            pitchObject.add(camera);
            scene.add(yawObject);

            let cameraDistance = 8;
            const minDistance = 4;
            const maxDistance = 15;
            camera.position.set(0, 3, cameraDistance);

            document.addEventListener("wheel", (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
            }, { passive: false });

            // ==================== –û–°–í–ï–©–ï–ù–ò–ï ====================
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(20, 30, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // ==================== –§–ò–ó–ò–ö–ê ====================
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);

            const groundMaterial = new CANNON.Material("groundMaterial");
            const playerMaterial = new CANNON.Material("playerMaterial");
            
            const contactMaterial = new CANNON.ContactMaterial(playerMaterial, groundMaterial, {
                friction: 0.0,
                restitution: 0.0,
            });
            world.addContactMaterial(contactMaterial);
            world.defaultContactMaterial = contactMaterial;

            // ==================== –ö–†–ê–°–ù–´–ï –ë–õ–û–ö–ò ====================
            const deathBlocks = [];

            // ==================== –£–†–û–í–ï–ù–¨ ====================
            
            // –ó–µ–º–ª—è
            const groundMesh = new THREE.Mesh(
                new THREE.BoxGeometry(30, 2, 30),
                new THREE.MeshStandardMaterial({ color: 0x3a4a5a })
            );
            groundMesh.position.set(0, -1, 10);
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            groundBody.addShape(new CANNON.Box(new CANNON.Vec3(15, 1, 15)));
            groundBody.position.copy(groundMesh.position);
            world.addBody(groundBody);

            // –£—Ä–æ–≤–µ–Ω—å 1
            for (let i = 0; i < 15; i++) {
                const platformMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 8),
                    new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i / 15, 0.8, 0.5) })
                );
                platformMesh.position.set(0, 2, -i * 10);
                platformMesh.castShadow = true;
                platformMesh.receiveShadow = true;
                scene.add(platformMesh);

                const platformBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                platformBody.addShape(new CANNON.Box(new CANNON.Vec3(4, 0.5, 4)));
                platformBody.position.copy(platformMesh.position);
                world.addBody(platformBody);
            }

            // –£—Ä–æ–≤–µ–Ω—å 2 —Å –∫—Ä–∞—Å–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏
            const startZ = -160;
            for (let i = 0; i < 20; i++) {
                const platformMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                platformMesh.position.set(0, 2, startZ - i * 10);
                platformMesh.castShadow = true;
                platformMesh.receiveShadow = true;
                scene.add(platformMesh);

                const platformBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                platformBody.addShape(new CANNON.Box(new CANNON.Vec3(4, 0.5, 4)));
                platformBody.position.copy(platformMesh.position);
                world.addBody(platformBody);

                for (let x = -3; x <= 3; x += 3) {
                    if (x === 0) continue;
                    if (Math.random() > 0.35) {
                        const deathMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 1, 2),
                            new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x330000 })
                        );
                        deathMesh.position.set(x, 3, startZ - i * 10);
                        deathMesh.castShadow = true;
                        deathMesh.receiveShadow = true;
                        scene.add(deathMesh);

                        const deathBody = new CANNON.Body({ 
                            mass: 0,
                            material: groundMaterial,
                            collisionResponse: false
                        });
                        deathBody.addShape(new CANNON.Box(new CANNON.Vec3(1, 0.5, 1)));
                        deathBody.position.copy(deathMesh.position);
                        world.addBody(deathBody);
                        
                        deathBlocks.push(deathBody);
                    }
                }
            }

            // ==================== –õ–û–ö–ê–õ–¨–ù–´–ô –ò–ì–†–û–ö ====================
            const localPlayerBody = new CANNON.Body({
                mass: 5,
                material: playerMaterial,
                linearDamping: 0.0,
                angularDamping: 0.0,
                fixedRotation: true,
                collisionResponse: true
            });
            localPlayerBody.addShape(new CANNON.Sphere(0.9));
            localPlayerBody.position.set(0, 8, 5);
            world.addBody(localPlayerBody);

            const spawnPosition = new CANNON.Vec3(0, 8, 5);

            // ==================== –ú–û–î–ï–õ–¨ –ò–ì–†–û–ö–ê ====================
            function createPlayerModel(hue = null) {
                const group = new THREE.Group();
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω
                const colorHue = hue !== null ? hue : Math.random();
                
                const bodyMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(colorHue, 0.8, 0.5) });
                const limbMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(colorHue, 0.7, 0.4) });
                const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });

                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 0.8), bodyMat);
                torso.position.y = 1.6;
                torso.castShadow = true;
                group.add(torso);

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), headMat);
                head.position.y = 3;
                head.castShadow = true;
                group.add(head);

                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), limbMat);
                leftLeg.position.set(-0.4, 0.2, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);

                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), limbMat);
                rightLeg.position.set(0.4, 0.2, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);

                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), limbMat);
                leftArm.position.set(-0.8, 1.8, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), limbMat);
                rightArm.position.set(0.8, 1.8, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                return group;
            }

            // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            const localColor = Math.random();
            const localModel = createPlayerModel(localColor);
            scene.add(localModel);

            // ==================== –ú–û–ë–ò–õ–¨–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï ====================
            
            // –î–∂–æ–π—Å—Ç–∏–∫
            const joystick = document.getElementById('touch-joystick');
            const handle = document.getElementById('joystick-handle');
            let joystickActive = false;
            let joystickVector = { x: 0, y: 0 };
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e.touches[0]);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) updateJoystick(e.touches[0]);
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickVector = { x: 0, y: 0 };
                handle.style.transform = 'translate(0px, 0px)';
            });
            
            function updateJoystick(touch) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                
                const distance = Math.sqrt(dx*dx + dy*dy);
                const maxDistance = rect.width / 2;
                
                if (distance > maxDistance) {
                    dx = (dx / distance) * maxDistance;
                    dy = (dy / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(${dx}px, ${dy}px)`;
                
                joystickVector.x = dx / maxDistance;
                joystickVector.y = dy / maxDistance;
            }
            
            // –ö–Ω–æ–ø–∫–∞ –ø—Ä—ã–∂–∫–∞
            const jumpBtn = document.getElementById('jump-button');
            let jumpPressed = false;
            
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                jumpPressed = true;
                jumpBtn.classList.add('active');
            });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                jumpPressed = false;
                jumpBtn.classList.remove('active');
            });
            
            // –ñ–µ—Å—Ç—ã –∫–∞–º–µ—Ä—ã
            const gestureArea = document.getElementById('gesture-area');
            
            let gestureTouches = [];
            let lastSingleTouch = null;
            
            function handleGestureStart(e) {
                e.preventDefault();
                updateTouches(e);
                if (gestureTouches.length === 1) {
                    lastSingleTouch = {
                        x: gestureTouches[0].clientX,
                        y: gestureTouches[0].clientY
                    };
                }
            }
            
            function handleGestureMove(e) {
                e.preventDefault();
                const prevTouches = [...gestureTouches];
                updateTouches(e);
                
                // –ü–∏–Ω—á-–∑—É–º
                if (gestureTouches.length === 2 && prevTouches.length === 2) {
                    const dx = gestureTouches[0].clientX - gestureTouches[1].clientX;
                    const dy = gestureTouches[0].clientY - gestureTouches[1].clientY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    const pdx = prevTouches[0].clientX - prevTouches[1].clientX;
                    const pdy = prevTouches[0].clientY - prevTouches[1].clientY;
                    const prevDist = Math.sqrt(pdx*pdx + pdy*pdy);
                    
                    const delta = prevDist - dist;
                    cameraDistance += delta * 0.02;
                    cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
                }
                
                // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
                if (gestureTouches.length === 1 && lastSingleTouch) {
                    const touch = gestureTouches[0];
                    
                    const deltaX = touch.clientX - lastSingleTouch.x;
                    const deltaY = touch.clientY - lastSingleTouch.y;
                    
                    yawObject.rotation.y -= deltaX * 0.005;
                    pitchObject.rotation.x -= deltaY * 0.003;
                    pitchObject.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitchObject.rotation.x));
                    
                    lastSingleTouch = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                }
            }
            
            function handleGestureEnd(e) {
                e.preventDefault();
                updateTouches(e);
                if (gestureTouches.length === 0) {
                    lastSingleTouch = null;
                } else if (gestureTouches.length === 1) {
                    lastSingleTouch = {
                        x: gestureTouches[0].clientX,
                        y: gestureTouches[0].clientY
                    };
                }
            }
            
            function updateTouches(e) {
                gestureTouches = [];
                for (let i = 0; i < e.touches.length; i++) {
                    gestureTouches.push(e.touches[i]);
                }
            }
            
            gestureArea.addEventListener('touchstart', handleGestureStart);
            gestureArea.addEventListener('touchmove', handleGestureMove);
            gestureArea.addEventListener('touchend', handleGestureEnd);
            gestureArea.addEventListener('touchcancel', handleGestureEnd);

            // ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –î–õ–Ø –ü–ö ====================
            const keys = {};
            document.addEventListener("keydown", (e) => keys[e.code] = true);
            document.addEventListener("keyup", (e) => keys[e.code] = false);
            document.addEventListener("contextmenu", (e) => e.preventDefault());

            let mouseDown = false;
            document.addEventListener("mousedown", (e) => {
                if (e.button === 2) mouseDown = true;
            });
            document.addEventListener("mouseup", (e) => {
                if (e.button === 2) mouseDown = false;
            });
            document.addEventListener("mousemove", (e) => {
                if (!mouseDown) return;
                yawObject.rotation.y -= e.movementX * 0.002;
                pitchObject.rotation.x -= e.movementY * 0.002;
                pitchObject.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitchObject.rotation.x));
            });

            // ==================== –ü–†–´–ñ–û–ö ====================
            let jumpCooldown = 2.0;
            let lastJumpTime = -Infinity;

            function respawn() {
                localPlayerBody.position.copy(spawnPosition);
                localPlayerBody.velocity.set(0, 0, 0);
            }

            // ==================== –ê–ù–ò–ú–ê–¶–ò–Ø ====================
            function animatePlayer(model, walkTimeValue, isMoving) {
                if (!model) return;
                
                // –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏
                if (model.children.length >= 6) {
                    const leftLeg = model.children[2];
                    const rightLeg = model.children[3];
                    const leftArm = model.children[4];
                    const rightArm = model.children[5];
                    
                    if (isMoving) {
                        const swing = Math.sin(walkTimeValue) * 0.7;
                        leftLeg.rotation.x = swing;
                        rightLeg.rotation.x = -swing;
                        leftArm.rotation.x = -swing;
                        rightArm.rotation.x = swing;
                    } else {
                        leftLeg.rotation.x = 0;
                        rightLeg.rotation.x = 0;
                        leftArm.rotation.x = 0;
                        rightArm.rotation.x = 0;
                    }
                }
            }

            // ==================== –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ====================
            const clock = new THREE.Clock();
            let walkTime = 0;
            const deathHeight = -20;

            function animate() {
                requestAnimationFrame(animate);

                const delta = Math.min(clock.getDelta(), 0.1);
                const elapsedTime = performance.now() / 1000;

                world.step(1 / 60, delta, 3);

                // –°–º–µ—Ä—Ç—å
                let dead = false;

                if (localPlayerBody.position.y < deathHeight) {
                    dead = true;
                }

                if (!dead) {
                    const playerPos = localPlayerBody.position;
                    const playerRadius = 0.9;

                    for (let block of deathBlocks) {
                        const blockPos = block.position;
                        const halfExtents = new CANNON.Vec3(1, 0.5, 1);
                        
                        const dx = playerPos.x - blockPos.x;
                        const dy = playerPos.y - blockPos.y;
                        const dz = playerPos.z - blockPos.z;

                        const closestX = Math.max(-halfExtents.x, Math.min(halfExtents.x, dx));
                        const closestY = Math.max(-halfExtents.y, Math.min(halfExtents.y, dy));
                        const closestZ = Math.max(-halfExtents.z, Math.min(halfExtents.z, dz));

                        const distX = dx - closestX;
                        const distY = dy - closestY;
                        const distZ = dz - closestZ;

                        if (distX*distX + distY*distY + distZ*distZ < playerRadius * playerRadius) {
                            dead = true;
                            break;
                        }
                    }
                }

                if (dead) {
                    respawn();
                }

                // –î–≤–∏–∂–µ–Ω–∏–µ
                if (!dead) {
                    const moveSpeed = 12;
                    
                    let moveX = 0, moveZ = 0;
                    
                    if (keys["KeyW"]) moveZ += 1;
                    if (keys["KeyS"]) moveZ -= 1;
                    if (keys["KeyA"]) moveX -= 1;
                    if (keys["KeyD"]) moveX += 1;
                    
                    if (joystickActive) {
                        moveX += joystickVector.x;
                        moveZ += -joystickVector.y;
                    }
                    
                    if (moveX !== 0 || moveZ !== 0) {
                        const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                        moveX /= len;
                        moveZ /= len;
                        
                        const angle = Math.atan2(moveX, moveZ);
                        localModel.rotation.y = angle;
                    }

                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);
                    
                    forward.y = 0;
                    right.y = 0;
                    forward.normalize();
                    right.normalize();
                    
                    localPlayerBody.velocity.x = (forward.x * moveZ + right.x * moveX) * moveSpeed;
                    localPlayerBody.velocity.z = (forward.z * moveZ + right.z * moveX) * moveSpeed;

                    const shouldJump = keys["Space"] || jumpPressed;
                    if (shouldJump) {
                        if (Math.abs(localPlayerBody.velocity.y) < 0.1) {
                            const currentTime = elapsedTime;
                            if (currentTime - lastJumpTime >= jumpCooldown) {
                                localPlayerBody.velocity.y = 10;
                                lastJumpTime = currentTime;
                            }
                        }
                    }
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è
                const moving = Math.abs(localPlayerBody.velocity.x) > 0.1 || Math.abs(localPlayerBody.velocity.z) > 0.1;
                if (moving) {
                    walkTime += delta * 12;
                }
                animatePlayer(localModel, walkTime, moving);

                // –û–±–Ω–æ–≤–ª—è–µ–º –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
                otherPlayers.forEach((player) => {
                    if (player.model && player.targetPos) {
                        // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
                        player.model.position.lerp(player.targetPos, 0.3);
                        animatePlayer(player.model, player.walkTime || 0, player.moving || false);
                    }
                });

                // –ö–∞–º–µ—Ä–∞
                const firstPerson = cameraDistance <= minDistance + 0.2;
                if (firstPerson) {
                    camera.position.set(0, 3, 0.5);
                    localModel.visible = false;
                } else {
                    camera.position.set(0, 3, cameraDistance);
                    localModel.visible = true;
                }

                localModel.position.copy(localPlayerBody.position);
                yawObject.position.copy(localPlayerBody.position);

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ 10 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
            setInterval(() => {
                broadcastPosition();
            }, 100);

        })();
    </script>
</body>
</html>
