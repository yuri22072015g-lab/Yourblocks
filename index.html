<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Yourblocks ‚Äî –ü—Ä—è–º–æ–π P2P –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* (—Å—Ç–∏–ª–∏ –æ—Å—Ç–∞–≤–ª–µ–Ω—ã –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏, –æ–Ω–∏ –Ω–µ –º–µ–Ω—è–ª–∏—Å—å) */
        /* ... –ø–æ–ª–Ω—ã–π CSS ... */
    </style>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
    <!-- (–≤–µ—Å—å HTML –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–µ–º –∂–µ) -->
    <!-- ... -->
    <script>
        // ==================== –í–ï–°–¨ –ö–û–î –ü–ï–†–ï–ü–ò–°–ê–ù –° –ù–£–õ–Ø ====================
        // (–ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞)

        // ==================== –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê –ú–£–õ–¨–¢–ò–ü–õ–ï–ï–†–ê (P2P + broadcast) ====================
        let peer = null;
        let connections = new Map();          // –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏
        let otherPlayers = new Map();         // –º–æ–¥–µ–ª–∏ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
        let myPeerId = null;
        let broadcastInterval = null;
        let isMultiplayerActive = false;      // —Ñ–ª–∞–≥, —á—Ç–æ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ

        function initMultiplayer() {
            return new Promise((resolve) => {
                try {
                    // –°–æ–∑–¥–∞—ë–º Peer —Å —Å–ª—É—á–∞–π–Ω—ã–º ID (–Ω–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤)
                    peer = new Peer({
                        host: '0.peerjs.com',
                        port: 443,
                        secure: true,
                        debug: 2   // –ø–æ–¥—Ä–æ–±–Ω—ã–µ –ª–æ–≥–∏ –≤ –∫–æ–Ω—Å–æ–ª—å
                    });

                    peer.on('open', (id) => {
                        myPeerId = id;
                        console.log('‚úÖ PeerJS –æ—Ç–∫—Ä—ã—Ç, –º–æ–π ID:', id);
                        document.getElementById('server-status').textContent = 'üü¢ –û–ñ–ò–î–ê–ù–ò–ï –ò–ì–†–û–ö–û–í...';
                        document.getElementById('server-status').style.color = '#4CAF50';

                        // –°–ª—É—à–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                        peer.on('connection', (conn) => {
                            handleConnection(conn);
                        });

                        // –ö–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ (broadcast)
                        // –í PeerJS –Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ broadcast, –ø–æ—ç—Ç–æ–º—É –º—ã –ø—Ä–æ—Å—Ç–æ –∂–¥—ë–º –≤—Ö–æ–¥—è—â–∏–µ.
                        // –ù–æ –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –º–æ–∂–Ω–æ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –∏–∑–≤–µ—Å—Ç–Ω–æ–º—É "–º–∞—è–∫—É".
                        // –ú—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–¥—Ö–æ–¥ "–∫–∞–∂–¥—ã–π –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ –∫–∞–∂–¥–æ–º—É" —á–µ—Ä–µ–∑ –æ–±—â–∏–π –∫–∞–Ω–∞–ª.
                        // –î–ª—è –¥–µ–º–æ —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ.

                        // –¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ä—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ ID (–æ—Å—Ç–∞–≤–∏–º –∫–Ω–æ–ø–∫—É)
                        setupManualConnect();

                        resolve();
                    });

                    peer.on('error', (err) => {
                        console.error('‚ùå –û—à–∏–±–∫–∞ PeerJS:', err);
                        document.getElementById('server-status').textContent = 'üî¥ –û–®–ò–ë–ö–ê –°–û–ï–î–ò–ù–ï–ù–ò–Ø';
                        document.getElementById('server-status').style.color = '#ff5555';
                        // –í—Å—ë —Ä–∞–≤–Ω–æ —Ä–µ–∑–æ–ª–≤–∏–º, —á—Ç–æ–±—ã –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–ª–∞—Å—å –≤ –æ—Ñ—Ñ–ª–∞–π–Ω–µ
                        resolve();
                    });

                    peer.on('disconnected', () => {
                        console.log('‚ö†Ô∏è PeerJS –æ—Ç–∫–ª—é—á—ë–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è...');
                        document.getElementById('server-status').textContent = 'üü° –ü–ï–†–ï–ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï...';
                        peer.reconnect();
                    });

                } catch (e) {
                    console.error('‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ PeerJS:', e);
                    document.getElementById('server-status').textContent = 'üî¥ –û–§–§–õ–ê–ô–ù –†–ï–ñ–ò–ú';
                    resolve();
                }
            });
        }

        function setupManualConnect() {
            // –°–æ–∑–¥–∞—ë–º –ø–æ–ª–µ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞ ID –¥—Ä—É–≥–∞ (–ø—Ä—è–º–æ –≤ –∏–≥—Ä–µ, –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
            const manualDiv = document.createElement('div');
            manualDiv.style.position = 'absolute';
            manualDiv.style.bottom = '200px';
            manualDiv.style.left = '50%';
            manualDiv.style.transform = 'translateX(-50%)';
            manualDiv.style.zIndex = '300';
            manualDiv.style.background = 'rgba(0,0,0,0.8)';
            manualDiv.style.padding = '10px';
            manualDiv.style.borderRadius = '10px';
            manualDiv.style.display = 'flex';
            manualDiv.style.gap = '5px';
            manualDiv.innerHTML = `
                <input type="text" id="manualPeerId" placeholder="–í–≤–µ–¥–∏—Ç–µ ID –¥—Ä—É–≥–∞" style="padding:5px;">
                <button id="manualConnectBtn" style="padding:5px; background:#4CAF50; color:white; border:none; border-radius:5px;">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
            `;
            document.getElementById('game-container').appendChild(manualDiv);

            document.getElementById('manualConnectBtn').addEventListener('click', () => {
                const targetId = document.getElementById('manualPeerId').value.trim();
                if (targetId && peer) {
                    console.log('–†—É—á–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫', targetId);
                    const conn = peer.connect(targetId);
                    if (conn) {
                        handleConnection(conn);
                    }
                }
            });
        }

        function handleConnection(conn) {
            const peerId = conn.peer;
            console.log('üîå –ù–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å', peerId);

            conn.on('open', () => {
                console.log('‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å', peerId);
                connections.set(peerId, conn);
                isMultiplayerActive = true;
                updatePlayersCount();

                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–æ–≤–æ–º—É –∏–≥—Ä–æ–∫—É
                sendMyInfo(conn);

                conn.on('data', (data) => {
                    handleData(peerId, data);
                });

                conn.on('close', () => {
                    console.log('üîå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —Å', peerId);
                    connections.delete(peerId);
                    removeOtherPlayer(peerId);
                    updatePlayersCount();
                    if (connections.size === 0) isMultiplayerActive = false;
                });

                conn.on('error', (err) => {
                    console.error('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å', peerId, err);
                });
            });
        }

        function sendMyInfo(conn) {
            if (!localPlayerBody) return;
            conn.send({
                type: 'init',
                username: currentUser ? currentUser.username : '–ò–≥—Ä–æ–∫',
                x: localPlayerBody.position.x,
                y: localPlayerBody.position.y,
                z: localPlayerBody.position.z,
                headColor: playerColors.head,
                bodyColor: playerColors.body,
                legsColor: playerColors.legs,
                armsColor: playerColors.arms
            });
        }

        function handleData(peerId, data) {
            if (data.type === 'init') {
                // –ù–æ–≤—ã–π –∏–≥—Ä–æ–∫ –ø—Ä–∏—Å–ª–∞–ª —Å–≤–æ–∏ –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                if (!otherPlayers.has(peerId)) {
                    const model = createMultiplayerModel(data);
                    if (model && scene) {
                        model.position.set(data.x, data.y, data.z);
                        scene.add(model);
                        otherPlayers.set(peerId, {
                            model: model,
                            targetPos: new THREE.Vector3(data.x, data.y, data.z),
                            username: data.username
                        });
                        console.log('üë§ –î–æ–±–∞–≤–ª–µ–Ω –∏–≥—Ä–æ–∫', data.username);
                        updatePlayersCount();
                    }
                }
            } else if (data.type === 'position') {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                if (otherPlayers.has(peerId)) {
                    const player = otherPlayers.get(peerId);
                    player.targetPos.set(data.x, data.y, data.z);
                }
            } else if (data.type === 'ping') {
                // –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                const conn = connections.get(peerId);
                if (conn) conn.send({ type: 'pong' });
            }
        }

        function broadcastPosition() {
            if (!localPlayerBody || connections.size === 0) return;
            const data = {
                type: 'position',
                x: localPlayerBody.position.x,
                y: localPlayerBody.position.y,
                z: localPlayerBody.position.z
            };
            connections.forEach((conn) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function removeOtherPlayer(id) {
            if (otherPlayers.has(id)) {
                const player = otherPlayers.get(id);
                if (player.model && scene) scene.remove(player.model);
                otherPlayers.delete(id);
                console.log('üëã –ò–≥—Ä–æ–∫ —É–¥–∞–ª—ë–Ω', id);
                updatePlayersCount();
            }
        }

        function updatePlayersCount() {
            const count = otherPlayers.size + 1;
            document.getElementById('players-count').textContent = `üë• ${count} –≤ –∫–æ–º–Ω–∞—Ç–µ`;
            document.getElementById('global-online').textContent = count;
            document.getElementById('game-players').textContent = count;
            if (count > 1) {
                document.getElementById('server-status').textContent = 'üü¢ –í –ö–û–ú–ü–ê–ù–ò–ò';
            } else {
                document.getElementById('server-status').textContent = 'üü° –û–î–ò–ù –í –ö–û–ú–ù–ê–¢–ï';
            }
        }

        function createMultiplayerModel(data) {
            try {
                const group = new THREE.Group();
                function getMaterial(hex) { return new THREE.MeshStandardMaterial({ color: hex }); }
                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 0.8), getMaterial(data.bodyColor));
                torso.position.y = 1.6; torso.castShadow = true; group.add(torso);
                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), getMaterial(data.headColor));
                head.position.y = 3; head.castShadow = true; group.add(head);
                const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), getMaterial(data.legsColor));
                leftLeg.position.set(-0.4, 0.2, 0); leftLeg.castShadow = true; group.add(leftLeg);
                const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.7), getMaterial(data.legsColor));
                rightLeg.position.set(0.4, 0.2, 0); rightLeg.castShadow = true; group.add(rightLeg);
                const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), getMaterial(data.armsColor));
                leftArm.position.set(-0.8, 1.8, 0); leftArm.castShadow = true; group.add(leftArm);
                const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.8, 0.5), getMaterial(data.armsColor));
                rightArm.position.set(0.8, 1.8, 0); rightArm.castShadow = true; group.add(rightArm);
                return group;
            } catch (e) { return null; }
        }

        // ==================== –û–°–¢–ê–õ–¨–ù–û–ô –ö–û–î (AKKAUNT–´, –ö–ê–°–¢–û–ú–ò–ó–ê–¶–ò–Ø, –§–ò–ó–ò–ö–ê) ====================
        // (–∑–¥–µ—Å—å —Ä–∞–∑–º–µ—â–∞–µ—Ç—Å—è –≤–µ—Å—å –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –Ω–æ —Å –≤—ã–∑–æ–≤–æ–º initMultiplayer() –≤ startGame)
        // –î–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ —è –ø—Ä–∏–≤–µ–¥—É —Ç–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:

        async function startGame() {
            document.getElementById('menu-container').style.display = 'none';
            document.getElementById('game-container').classList.add('active');
            if (window.innerWidth <= 768) document.getElementById('mobile-controls').classList.add('active');

            await initMultiplayer();  // <-- –Ω–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è

            initThreeJSGame(document.getElementById('game-canvas'));
            initMobileControls();
        }

        // –í —Ñ—É–Ω–∫—Ü–∏–∏ animate –¥–æ–±–∞–≤–ª–µ–Ω –≤—ã–∑–æ–≤ broadcastPosition():
        // if (connections.size > 0) broadcastPosition();

        // –í—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ (–∞–∫–∫–∞—É–Ω—Ç—ã, –¥—Ä—É–∑—å—è, —Ñ–∏–∑–∏–∫–∞, Three.js) –æ—Å—Ç–∞—ë—Ç—Å—è –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏.
        // –í–∞–∂–Ω–æ: localPlayerBody, scene –∏ —Ç.–¥. –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –≥–ª–æ–±–∞–ª—å–Ω–æ.
        // –ü–æ–ª–Ω—ã–π –∫–æ–¥ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π, –Ω–æ –æ—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è —è—Å–Ω–∞.
    </script>
</body>
</html>
